<!DOCTYPE html><html><head></head><body>lang="en"&gt;

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Mercury Forest</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            position: relative;
        }
    </style>

<base target="_self">


    <div id="canvas-container"></div>

    <script>
        const sketch = (p) => {
            let trees = [];
            let maxTrees = 30;
            let ground;
            let audioContext, gainNode, oscillator;
            let isAudioEnabled = false;
            let mouseForce = 0;
            let neonPulse = 0;
            let lastClickTime = 0;
            let clickEffectRadius = 0;

            p.setup = () => {
                let canvas = p.createCanvas(p.min(p.windowWidth, 1200), p.windowHeight);
                canvas.parent('canvas-container');
                p.colorMode(p.HSB, 360, 100, 100, 1);
                p.angleMode(p.DEGREES);

                // Initialize audio context (will be activated on interaction)
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioContext.createGain();
                    gainNode.gain.value = 0;
                    gainNode.connect(audioContext.destination);
                    isAudioEnabled = true;
                } catch (e) {
                    isAudioEnabled = false;
                }

                // Create mercury trees
                for (let i = 0; i < maxTrees; i++) {
                    trees.push(createTree(p.random(p.width), p.random(p.height * 0.7)));
                }

                // Create ground graphics
                ground = p.createGraphics(p.width, p.height * 0.3);
            };

            function createTree(x, y) {
                let height = p.random(100, 300);
                let segments = p.floor(p.random(8, 15));
                let baseWidth = p.random(20, 50);
                return {
                    x: x,
                    y: y,
                    baseY: y,
                    height: height,
                    segments: segments,
                    baseWidth: baseWidth,
                    wobble: p.random(360),
                    wobbleSpeed: p.random(0.5, 2),
                    bendFactor: 0,
                    targetBend: 0,
                    mercuryColor: p.color(180, 30, 90, 0.8),
                    highlightColor: p.color(180, 20, 100, 0.9)
                };
            }

            function updateTree(tree) {
                // Wobble animation
                tree.wobble += tree.wobbleSpeed;
                
                // Bend towards mouse
                let mouseDist = p.dist(p.mouseX, p.mouseY, tree.x, tree.baseY);
                tree.targetBend = p.constrain(p.map(mouseDist, 0, 300, 60, 0), 0, 60);
                tree.bendFactor = p.lerp(tree.bendFactor, tree.targetBend, 0.1);
                
                // Play sound when bending significantly
                if (isAudioEnabled && tree.bendFactor > 30 && p.frameCount % 30 === 0) {
                    playMetallicSound(tree.bendFactor / 60);
                }
            }

            function drawTree(tree) {
                p.push();
                p.translate(tree.x, tree.baseY);
                
                // Draw mercury trunk
                p.noStroke();
                for (let i = 0; i < tree.segments; i++) {
                    let segmentHeight = tree.height / tree.segments;
                    let segmentY = -i * segmentHeight;
                    let segmentWidth = p.map(i, 0, tree.segments, tree.baseWidth, tree.baseWidth * 0.3);
                    
                    // Apply bending
                    let bendAngle = p.map(i, 0, tree.segments, tree.bendFactor * p.sin(tree.wobble + i * 10), 0);
                    p.push();
                    p.rotate(bendAngle);
                    
                    // Draw segment
                    let segmentHue = p.map(i, 0, tree.segments, 180, 200);
                    p.fill(p.lerpColor(tree.mercuryColor, tree.highlightColor, p.noise(i * 0.2, p.frameCount * 0.01)));
                    p.ellipse(0, segmentY, segmentWidth, segmentHeight * 1.2);
                    
                    // Add mercury highlights
                    p.fill(180, 10, 100, 0.6);
                    p.arc(0, segmentY, segmentWidth * 0.8, segmentHeight * 0.8, 180, 360);
                    p.pop();
                }
                
                // Draw canopy
                p.fill(200, 40, 90, 0.7);
                p.ellipse(tree.bendFactor * 0.5, -tree.height, tree.baseWidth * 1.5, tree.baseWidth);
                p.pop();
            }

            function updateGround() {
                ground.clear();
                
                // Draw obsidian ground
                ground.fill(240, 100, 10, 1);
                ground.rect(0, 0, p.width, ground.height);
                
                // Draw neon veins
                ground.strokeWeight(2);
                neonPulse = p.sin(p.frameCount * 0.5) * 0.2 + 0.8;
                
                for (let i = 0; i < 20; i++) {
                    let x = p.noise(i * 100, p.frameCount * 0.01) * p.width;
                    let y = p.map(p.noise(i * 50, p.frameCount * 0.02), 0, 1, 5, ground.height - 5);
                    let hue = (p.frameCount * 0.5 + i * 20) % 360;
                    
                    ground.stroke(hue, 100, 100 * neonPulse, 0.7);
                    ground.noFill();
                    ground.beginShape();
                    for (let j = 0; j < 10; j++) {
                        let px = x + p.noise(i, j * 0.5, p.frameCount * 0.01) * 100 - 50;
                        let py = y + p.noise(j, i * 0.5, p.frameCount * 0.02) * 20 - 10;
                        ground.curveVertex(px, py);
                    }
                    ground.endShape();
                }
                
                // Add click effect
                if (clickEffectRadius > 0) {
                    let alpha = p.map(clickEffectRadius, 0, 300, 0.8, 0);
                    ground.fill(200, 100, 100, alpha * 0.5);
                    ground.noStroke();
                    ground.ellipse(p.mouseX, 0, clickEffectRadius * 2, clickEffectRadius * 0.5);
                    clickEffectRadius *= 0.95;
                }
            }

            function playMetallicSound(intensity) {
                if (!isAudioEnabled) return;
                
                if (!oscillator) {
                    oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.connect(gainNode);
                    oscillator.start();
                }
                
                // Set frequency based on intensity (higher pitch for more bending)
                oscillator.frequency.setValueAtTime(220 + intensity * 880, audioContext.currentTime);
                
                // Create metallic envelope
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1 * intensity, audioContext.currentTime);
            }

            p.draw = () => {
                // Dark gradient background
                let bg = p.drawingContext.createLinearGradient(0, 0, 0, p.height);
                bg.addColorStop(0, p.color(240, 100, 10));
                bg.addColorStop(1, p.color(240, 100, 5));
                p.drawingContext.fillStyle = bg;
                p.rect(0, 0, p.width, p.height);
                
                // Update and draw trees
                trees.forEach(tree => {
                    updateTree(tree);
                    drawTree(tree);
                });
                
                // Update and draw ground
                updateGround();
                p.image(ground, 0, p.height - ground.height);
                
                // Interactive cursor effect
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    mouseForce = p.lerp(mouseForce, 1, 0.1);
                    
                    // Draw cursor ripple
                    p.noFill();
                    p.stroke(200, 100, 100, 0.5);
                    p.strokeWeight(2);
                    p.ellipse(p.mouseX, p.mouseY, mouseForce * 50, mouseForce * 50);
                } else {
                    mouseForce = p.lerp(mouseForce, 0, 0.1);
                }
            };

            p.mouseMoved = () => {
                // Trees will respond to mouse movement through their update function
            };

            p.mouseClicked = () => {
                clickEffectRadius = 150;
                lastClickTime = p.millis();
                
                // Create new tree on click
                if (trees.length < maxTrees) {
                    trees.push(createTree(p.mouseX, p.mouseY));
                }
                
                // Play stronger sound on click
                if (isAudioEnabled) {
                    playMetallicSound(1);
                }
            };

            p.touchStarted = () => {
                // Enable audio on first interaction (required for mobile)
                if (isAudioEnabled && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                return false; // Prevent default touch behavior
            };

            p.windowResized = () => {
                p.resizeCanvas(p.min(p.windowWidth, 1200), p.windowHeight);
                ground = p.createGraphics(p.width, p.height * 0.3);
            };
        };

        new p5(sketch);
    </script>

              
          
                
          
              
</body></html>